# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_DataFileIOLibrary')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_DataFileIOLibrary')
    _DataFileIOLibrary = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_DataFileIOLibrary', [dirname(__file__)])
        except ImportError:
            import _DataFileIOLibrary
            return _DataFileIOLibrary
        try:
            _mod = imp.load_module('_DataFileIOLibrary', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _DataFileIOLibrary = swig_import_helper()
    del swig_import_helper
else:
    import _DataFileIOLibrary
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0


def GetNumChannels(pJsonFile):
    return _DataFileIOLibrary.GetNumChannels(pJsonFile)
GetNumChannels = _DataFileIOLibrary.GetNumChannels

def ValidateSignals(pDbFile, pPrioritizedSignalJsonFile, pValidSignalJsonFile):
    return _DataFileIOLibrary.ValidateSignals(pDbFile, pPrioritizedSignalJsonFile, pValidSignalJsonFile)
ValidateSignals = _DataFileIOLibrary.ValidateSignals

def OpenDataFile(pDataFile, pJsonFile):
    return _DataFileIOLibrary.OpenDataFile(pDataFile, pJsonFile)
OpenDataFile = _DataFileIOLibrary.OpenDataFile

def GetMeasurementTimeBounds(indatapointer):
    return _DataFileIOLibrary.GetMeasurementTimeBounds(indatapointer)
GetMeasurementTimeBounds = _DataFileIOLibrary.GetMeasurementTimeBounds

def SetActiveMask(indatapointer, pMask):
    return _DataFileIOLibrary.SetActiveMask(indatapointer, pMask)
SetActiveMask = _DataFileIOLibrary.SetActiveMask

def JumpBeforeTimestamp(indatapointer, dTime):
    return _DataFileIOLibrary.JumpBeforeTimestamp(indatapointer, dTime)
JumpBeforeTimestamp = _DataFileIOLibrary.JumpBeforeTimestamp

def JumpAfterTimestamp(indatapointer, dTime):
    return _DataFileIOLibrary.JumpAfterTimestamp(indatapointer, dTime)
JumpAfterTimestamp = _DataFileIOLibrary.JumpAfterTimestamp

def GetNextRecord(indatapointer):
    return _DataFileIOLibrary.GetNextRecord(indatapointer)
GetNextRecord = _DataFileIOLibrary.GetNextRecord

def SetCursorsToStart(indatapointer):
    return _DataFileIOLibrary.SetCursorsToStart(indatapointer)
SetCursorsToStart = _DataFileIOLibrary.SetCursorsToStart

def CloseDataFile(indatapointer):
    return _DataFileIOLibrary.CloseDataFile(indatapointer)
CloseDataFile = _DataFileIOLibrary.CloseDataFile

def CreateDatabase(pMdfFile, pDbFile):
    return _DataFileIOLibrary.CreateDatabase(pMdfFile, pDbFile)
CreateDatabase = _DataFileIOLibrary.CreateDatabase

def CreateDatabaseForSignals(pMdfFile, pJsonFile, pDbFile):
    return _DataFileIOLibrary.CreateDatabaseForSignals(pMdfFile, pJsonFile, pDbFile)
CreateDatabaseForSignals = _DataFileIOLibrary.CreateDatabaseForSignals

def GetChannels(pMdfFile, pJsonFile):
    return _DataFileIOLibrary.GetChannels(pMdfFile, pJsonFile)
GetChannels = _DataFileIOLibrary.GetChannels

def GetChannelStatistics(pMdfFile, pJsonFile):
    return _DataFileIOLibrary.GetChannelStatistics(pMdfFile, pJsonFile)
GetChannelStatistics = _DataFileIOLibrary.GetChannelStatistics

import sys
import os
import numpy as np
import pprint
import json
class CreateDSR:
	def __init__(self):
		self.dsr =  {"HitLists" : []}

	def AddToDSR(self, data, callback, hitDiscretion = "Hit number "):
		'''
		the AddToDSR function takes two arguments the first being ICSData class and the second being a function with two paramaters as an argument
		The AddToDSR calls the function for every data point it iterates though to determan if it should be included in the DSR file
		'''
		numRec = 0
		triggered = False
		dsr = self.dsr
		curTimestamp = data.JumpAfterTimestamp(0)
		dsr["HitLists"].append({"FilenameAndPath": data.dbFileName})
		while curTimestamp != sys.float_info.max:
			if callback(data.GetPoints(), data.GetTimeStamps()):
				if not triggered:
					if "Hits" not in dsr["HitLists"][-1]:
						dsr["HitLists"][-1]["Hits"] = []
					dsr["HitLists"][-1]["Hits"].append({"Description" : hitDiscretion + str(numRec), "StartTimes": curTimestamp - data.GetMeasurementTimeBounds()[1]})
					numRec += 1
					triggered = True
			elif triggered:
				dsr["HitLists"][-1]["Hits"][-1]["EndTime"] = curTimestamp - data.GetMeasurementTimeBounds()[1]
				triggered = False
			curTimestamp = data.GetNextRecord()

	def save(self, filename = "data.dsr"):
		with open(filename, 'w') as outfile:
			json.dump(self.dsr, outfile)

class ICSDataFile:
	def __init__(self, dbFileName, jsonFileName, AutoCleanUpTempFiles = True):
		self.UsingTempFile = False
		if len(dbFileName) > 0:
			name, extension = os.path.splitext(dbFileName)
			if extension.lower() != ".db":
				if not os.path.isfile(name + ".db"):
					CreateDatabaseForSignals(dbFileName, jsonFileName, name + ".db")
					self.UsingTempFile = True
				dbFileName = name + ".db"

		self.dbFileName = dbFileName
		self.jsonFileName = jsonFileName
		self.AutoCleanUpTempFiles = AutoCleanUpTempFiles
		self.measStart, self.points, self.timestamps = OpenDataFile(self.dbFileName, self.jsonFileName)
		with open(jsonFileName) as data_file:  
			data = json.load(data_file)
			self.nameToIndex = { channel["name"]: index for index, channel in enumerate(data["Channels"])}
			self.indexToName = { index: channel["name"] for index, channel in enumerate(data["Channels"])}

	def __getitem__(self, key):
		''' this method of retrieving data is slower then simply asking for the timestamp and points array'''
		if type(key) == str and key in self.nameToIndex:
			index = self.nameToIndex[key]
			return {"name": key, "index": index, "point": self.points[index], "time": self.timestamps[index]}
		elif type(key) == int and key in self.indexToName:
			return {"name": self.indexToName[key], "index": key, "point": self.points[key], "time": self.timestamps[key]}
		else:
			{}

	def __enter__(self):
		return self

	def __exit__(self, exc_type, exc_value, traceback):
		CloseDataFile(self.points)
		if self.UsingTempFile and self.AutoCleanUpTempFiles:
			os.remove(self.dbFileName)

	def indexOfSignal(self, sigName):
		return self.nameToIndex[sigName] if sigName in self.nameToIndex else -1

	def __del__(self):
		CloseDataFile(self.points)
		if self.UsingTempFile and self.AutoCleanUpTempFiles:
			os.remove(self.dbFileName)

	def GetNumChannels(self):
		return GetNumChannels(self.jsonFileName)

	def GetMeasurementStart(self):
		return self.measStart

	def GetPoints(self):
		return self.points

	def GetTimeStamps(self):
		return self.timestamps

	def SetActiveMask(self, mask):
		""" Allows the user to position the time cursor just before or at the specified
		 *  time value.  This call updates the channel values and timestamps.  If only some 
		 *  channels are active, the nearest active channel's timestamp is used.
		 *  
		 *  If an error ocurred, the return value is DBL_MAX
		 *
		 *  Timestamps represent the number of seconds since January 1, 2007.  The decimals 
		 *  represent fractions of seconds.
		 *
		 *  @param dTime         The timestamp to jump to
		 *  @return The actual timestamp the cursor is on
		 """
		return SetActiveMask(self.points, mask)	

	def JumpAfterTimestamp(self, timestamp):
		""" Allows the user to position the time cursor just after or at the specified
		 *  time value.  This call updates the channel values and timestamps.  The first
		 *  timestamp where all channels have a value and which is at or after the requested
		 *  time.  If only some channels are active, the nearest active channel's timestamp is
		 *  used.
		 *  
		 *  If an error ocurred, the return value is DBL_MAX
		 *
		 *  Timestamps represent the number of seconds since January 1, 2007.  The decimals 
		 *  represent fractions of seconds.
		 *
		 *  @param dTime         The timestamp to jump to
		 *  @return The actual timestamp the cursor is on
		 """
		return JumpAfterTimestamp(self.points, timestamp) 

	def JumpBeforeTimestamp(self, timestamp):
		""" Allows the user to position the time cursor just before or at the specified
		 *  time value.  This call updates the channel values and timestamps.  The first
		 *  timestamp where all channels have a value and which is at or after the requested
		 *  time.  If only some channels are active, the nearest active channel's timestamp is
		 *  used.
		 *  
		 *  If an error ocurred, the return value is DBL_MAX
		 *
		 *  Timestamps represent the number of seconds since January 1, 2007.  The decimals 
		 *  represent fractions of seconds.
		 *
		 *  @param indatapointer The datapointer value received from the OpenDataFile call
		 *  @param n             The number of channels (size of the datapointer array)
		 *  @param dTime         The timestamp to jump to
		 *  @return The actual timestamp the cursor is on
		"""
		return JumpBeforeTimestamp(self.points, timestamp)

	def GetNextRecord(self):
		""" Advances the cursor to the next timestamp.  This call updates the channel
		 *  values and timestamps.  If only some channels are active, the next timestamp of
		 *  an active channel is the one returned.
		 *  
		 *  If an error ocurred, the return value is DBL_MAX
		 *
		 *  Timestamps represent the number of seconds since January 1, 2007.  The decimals 
		 *  represent fractions of seconds.
		 *
		 *  @param indatapointer The datapointer value received from the OpenDataFile call
		 *  @param n             The number of channels (size of the datapointer array)
		 *  @return The actual timestamp the cursor is on
		"""
		return GetNextRecord(self.points)


	def GetMeasurementTimeBounds(self):
		""" Returns the start and end or measurement times found in the file.
		 *  
		 *  If an error ocurred, the return value is 0.
		 *
		 *  Timestamps used throughout represent the number of seconds since
		 *  January 1, 2007.  The decimals represent fractions of seconds.
		 *
		 *  @param pMask         A string of size n containing the character '1' for active
		 *                       channels and '0' for non-active channels.  Please note that
		 *                       only '0' and '1' are valid values.
		 *  @return 1 for success, 0 for error, -1 for licensing issues
		"""
		return GetMeasurementTimeBounds(self.points) 	

#the following test function is simply here to test a basic example
def test():
	print("Start of Test")
	import tkinter as tk
	from tkinter import filedialog
	root = tk.Tk()
	root.withdraw()
	dbFileName = filedialog.askopenfilename(parent=root, filetypes = (("db files", "*.db"), ("All files", "*.*")))
	jsonFileName = filedialog.askopenfilename(parent=root, filetypes = (("json files", "*.json"), ("All files", "*.*")))
	data = ICSDataFile(dbFileName, jsonFileName)
	curTimestamp = data.JumpAfterTimestamp(0)
	minarray = np.copy(data.GetPoints())
	maxarray = np.copy(data.GetPoints())

	while curTimestamp != sys.float_info.max:
		np.minimum(minarray, data.GetPoints(), out=minarray)
		np.maximum(maxarray, data.GetPoints(), out=maxarray)		
		curTimestamp = data.GetNextRecord()

	print(minarray)
	print(maxarray)
	print("End of Test")

def test2():
	from  SigEnumFile import Sig 
	def cheekfullThrotel (values, timestamp):
		return values[Sig.AccelPedalPosition] > 80 and values[Sig.TransOutputSpeed] < 1600

	sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), os.path.pardir)))
	from Libraries import IPAInterfaceLibrary

	jsonFileName = IPAInterfaceLibrary.get_config_file()
	filenames = IPAInterfaceLibrary.get_input_file_list()
	dsr = CreateDSR()

	for filename in filenames:
		data = ICSDataFile(filename, jsonFileName)

		accelpedalPostionIndex = data.indexOfSignal("AccelPedalPosition")
		transOutputSpeedndex = data.indexOfSignal("TransOutputSpeed") 

		dsr.AppendToDSR(data, lambda p, t: p[accelpedalPostionIndex] > 80 and p[transOutputSpeedndex] < 1600)
		dsr.AppendToDSR(data, cheekfullThrotel, "Full Throtel hit")

	dsr.save()

if __name__ == "__main__":
	test2()

# This file is compatible with both classic and new-style classes.

# This file is compatible with both classic and new-style classes.


